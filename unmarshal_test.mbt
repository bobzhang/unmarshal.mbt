// Test data generated by OCaml marshal

// Test: int_0
///|
let int_0_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x01', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x40',
]

// Test: int_1

///|
let int_1_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x01', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x41',
]

// Test: int_42

///|
let int_42_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x01', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x6a',
]

// Test: int_63

///|
let int_63_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x01', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x7f',
]

// Test: int_100

///|
let int_100_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x02', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x64',
]

// Test: int_127

///|
let int_127_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x02', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x7f',
]

// Test: int_neg_1

///|
let int_neg_1_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x02', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\xff',
]

// Test: int_neg_128

///|
let int_neg_128_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x02', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x80',
]

// Test: int_1000

///|
let int_1000_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x03', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x03', b'\xe8',
]

// Test: int_32767

///|
let int_32767_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x03', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x7f', b'\xff',
]

// Test: int_neg_1000

///|
let int_neg_1000_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x03', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\xfc', b'\x18',
]

// Test: int_neg_32768

///|
let int_neg_32768_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x03', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x80', b'\x00',
]

// Test: int_100000

///|
let int_100000_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x05', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x02', b'\x00', b'\x01', b'\x86', b'\xa0',
]

// Test: int_2147483647

///|
let int_2147483647_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x09', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x03', b'\x00', b'\x00', b'\x00', b'\x00', b'\x7f', b'\xff',
  b'\xff', b'\xff',
]

// Test: int_neg_100000

///|
let int_neg_100000_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x05', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x02', b'\xff', b'\xfe', b'\x79', b'\x60',
]

// Test: int_neg_2147483648

///|
let int_neg_2147483648_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x09', b'\x00',
  b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00', b'\x00',
  b'\x00', b'\x00', b'\x03', b'\xff', b'\xff', b'\xff', b'\xff', b'\x80', b'\x00',
  b'\x00', b'\x00',
]

// Test: string_empty

///|
let string_empty_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x01', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x00', b'\x00', b'\x00', b'\x02', b'\x00', b'\x00',
  b'\x00', b'\x02', b'\x20',
]

// Test: string_a

///|
let string_a_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x02', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x00', b'\x00', b'\x00', b'\x02', b'\x00', b'\x00',
  b'\x00', b'\x02', b'\x21', b'\x61',
]

// Test: string_hello

///|
let string_hello_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x06', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x00', b'\x00', b'\x00', b'\x03', b'\x00', b'\x00',
  b'\x00', b'\x02', b'\x25', b'\x48', b'\x65', b'\x6c', b'\x6c', b'\x6f',
]

// Test: string_31chars

///|
let string_31chars_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x20', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x00', b'\x00', b'\x00', b'\x09', b'\x00', b'\x00',
  b'\x00', b'\x05', b'\x3f', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78',
  b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78',
  b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78',
  b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78', b'\x78',
]

// Test: string_32chars

///|
let string_32chars_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x22', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x00', b'\x00', b'\x00', b'\x0a', b'\x00', b'\x00',
  b'\x00', b'\x06', b'\x09', b'\x20', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79',
  b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79',
  b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79',
  b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79', b'\x79',
]

// Test: string_special

///|
let string_special_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x0e', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x00', b'\x00', b'\x00', b'\x05', b'\x00', b'\x00',
  b'\x00', b'\x03', b'\x2d', b'\x48', b'\x65', b'\x6c', b'\x6c', b'\x6f', b'\x0a',
  b'\x57', b'\x6f', b'\x72', b'\x6c', b'\x64', b'\x09', b'\x21',
]

// Test: string_unicode

///|
let string_unicode_data : Bytes = [
  b'\x84', b'\x95', b'\xa6', b'\xbe', b'\x00', b'\x00', b'\x00', b'\x12', b'\x00',
  b'\x00', b'\x00', b'\x01', b'\x00', b'\x00', b'\x00', b'\x06', b'\x00', b'\x00',
  b'\x00', b'\x04', b'\x31', b'\x48', b'\x65', b'\x6c', b'\x6c', b'\x6f', b'\x20',
  b'\xe4', b'\xb8', b'\x96', b'\xe7', b'\x95', b'\x8c', b'\x20', b'\xf0', b'\x9f',
  b'\x8c', b'\x8d',
]

///|
test "decode_small_integers" {
  // Test integer 0-63 which use single byte encoding
  let decoder0 = Decoder::new(int_0_data)
  let (_, value0) = decoder0.decode()
  inspect(value0, content="MInt(0)")
  let decoder1 = Decoder::new(int_1_data)
  let (_, value1) = decoder1.decode()
  inspect(value1, content="MInt(1)")
  let decoder42 = Decoder::new(int_42_data)
  let (_, value42) = decoder42.decode()
  inspect(value42, content="MInt(42)")
  let decoder63 = Decoder::new(int_63_data)
  let (_, value63) = decoder63.decode()
  inspect(value63, content="MInt(63)")
}

///|
test "decode_int8_range" {
  // Test integers that require CODE_INT8 encoding
  let decoder100 = Decoder::new(int_100_data)
  let (_, value100) = decoder100.decode()
  inspect(value100, content="MInt(100)")
  let decoder127 = Decoder::new(int_127_data)
  let (_, value127) = decoder127.decode()
  inspect(value127, content="MInt(127)")
  let decoder_neg1 = Decoder::new(int_neg_1_data)
  let (_, value_neg1) = decoder_neg1.decode()
  inspect(value_neg1, content="MInt(-1)")
  let decoder_neg128 = Decoder::new(int_neg_128_data)
  let (_, value_neg128) = decoder_neg128.decode()
  inspect(value_neg128, content="MInt(-128)")
}

///|
test "decode_int16_range" {
  // Test integers that require CODE_INT16 encoding
  let decoder1000 = Decoder::new(int_1000_data)
  let (_, value1000) = decoder1000.decode()
  inspect(value1000, content="MInt(1000)")
  let decoder32767 = Decoder::new(int_32767_data)
  let (_, value32767) = decoder32767.decode()
  inspect(value32767, content="MInt(32767)")
  let decoder_neg1000 = Decoder::new(int_neg_1000_data)
  let (_, value_neg1000) = decoder_neg1000.decode()
  inspect(value_neg1000, content="MInt(-1000)")
  let decoder_neg32768 = Decoder::new(int_neg_32768_data)
  let (_, value_neg32768) = decoder_neg32768.decode()
  inspect(value_neg32768, content="MInt(-32768)")
}

///|
test "decode_int32_range" {
  // Test integers that require CODE_INT32 encoding
  let decoder100000 = Decoder::new(int_100000_data)
  let (_, value100000) = decoder100000.decode()
  inspect(value100000, content="MInt(100000)")
  let decoder_max32 = Decoder::new(int_2147483647_data)
  let (_, value_max32) = decoder_max32.decode()
  inspect(value_max32, content="MInt(2147483647)")
  let decoder_neg100000 = Decoder::new(int_neg_100000_data)
  let (_, value_neg100000) = decoder_neg100000.decode()
  inspect(value_neg100000, content="MInt(-100000)")
  let decoder_min32 = Decoder::new(int_neg_2147483648_data)
  let (_, value_min32) = decoder_min32.decode()
  inspect(value_min32, content="MInt(-2147483648)")
}

///|
test "decode_small_strings" {
  // Test strings that use PREFIX_SMALL_STRING encoding (< 32 chars)
  let decoder_empty = Decoder::new(string_empty_data)
  let (_, value_empty) = decoder_empty.decode()
  inspect(value_empty, content="MString(b\"\")")
  let decoder_a = Decoder::new(string_a_data)
  let (_, value_a) = decoder_a.decode()
  inspect(
    value_a,
    content=(
      #|MString(b"\x61")
    ),
  )
  let decoder_hello = Decoder::new(string_hello_data)
  let (_, value_hello) = decoder_hello.decode()
  inspect(
    value_hello,
    content=(
      #|MString(b"\x48\x65\x6c\x6c\x6f")
    ),
  )
  let decoder_31 = Decoder::new(string_31chars_data)
  let (_, value_31) = decoder_31.decode()
  // Check it's 31 x's
  match value_31 {
    MString(bytes) => {
      assert_eq(bytes.length(), 31)
      assert_eq(bytes[0], b'x')
      assert_eq(bytes[30], b'x')
    }
    _ => abort("Expected MString")
  }
}

///|
test "decode_string8" {
  // Test strings that use CODE_STRING8 encoding (32-255 chars)
  let decoder_32 = Decoder::new(string_32chars_data)
  let (_, value_32) = decoder_32.decode()
  match value_32 {
    MString(bytes) => {
      assert_eq(bytes.length(), 32)
      assert_eq(bytes[0], b'y')
      assert_eq(bytes[31], b'y')
    }
    _ => abort("Expected MString")
  }
}

///|
test "decode_special_strings" {
  // Test strings with special characters
  let decoder_special = Decoder::new(string_special_data)
  let (_, value_special) = decoder_special.decode()
  inspect(
    value_special,
    content=(
      #|MString(b"\x48\x65\x6c\x6c\x6f\x0a\x57\x6f\x72\x6c\x64\x09\x21")
    ),
  )

  // Test Unicode string
  let decoder_unicode = Decoder::new(string_unicode_data)
  let (_, value_unicode) = decoder_unicode.decode()
  match value_unicode {
    MString(bytes) => {
      // "Hello 世界 🌍" in UTF-8
      assert_eq(bytes.length(), 17)
      // Check first 5 bytes are "Hello"
      assert_eq(bytes[0], b'H')
      assert_eq(bytes[1], b'e')
      assert_eq(bytes[2], b'l')
      assert_eq(bytes[3], b'l')
      assert_eq(bytes[4], b'o')
    }
    _ => abort("Expected MString")
  }
}
